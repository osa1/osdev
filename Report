# Report for Assignment 3

## Question 1

Synchronization is achieved using two semaphores: "produced" and "consumed".
"produced" is only signalled after a new value is produced. Before a new value is produced, producer waits for "consumed".
"consumed" is just the opposite. It's signalled after a value is consumed. Consumer waits for "produced" before consumes.

The control flow goes like this:

1. At first consumed = 0 and produced = 1.
2. Producer can't produce, because it waits for "consumed".
3. Consumer takes the "produced" semaphore, consumes the value, and signals "consumed".
4. Consumer is now blocked waiting for "produced", because it's just zeroed.
5. But producer can make progress, "consumed" is just signalled. It does the opposite, takes "consumed", produces a value, and signals "produced".
6. Producer is now blocked waiting for "consumed", just like what happened previously to consumer.
7. Now it's consumer's turn again. GOTO 3.

... and it goes like this. In the end, every produced value is consumed because there's no way for producer to produce twice without consumer consumes the produced value.

## Question 2

With only one semaphore all we can do is this:

producer:
  wait(sem);
  produce();
  signal(sem);

consumer:
  wait(sem);
  consume();
  signal(sem);

This makes sure that consuming and producing is not interleaved, but a value can still be consumed multiple times and some values may not be consumed at all. So with one semaphore we can't guarantee that every value is consumed.

## Code

See the git diff.


# Report for Assignment 2

## Question 1

Program consistently produced garbage. The reason is that both producer and
server are printing the produced/consumed values, and since printing is not an
atomic operation and since context switching can interrupt both sides in the
middle of printing process to switch to other process, output gets messed up.

## Question 2

Not all produced values are consumed. The reason is that context switching is
not happening deterministically, sometimes producer produces but before context
switching happens to let consumer consume the value, producer produces one more
value. So consumer sometimes missing some values.

## Functions


```c
shellcmd xsh_prodcons(int nargs, char *args[])
{
  n = 0;
  int count = 2000;

  if (nargs > 2) {
      printf(
          "ERROR: Wrong number of arguments given. Expected 1 or 0, found %d.\n"
          "USAGE: prodcons COUNT\n", nargs);
      return 1;
  }

  if (nargs == 2) {
    count = atoi(args[1]);
  }

  tid_typ producer_th = create(producer, 1024, 20, "producer", 3, count);
  tid_typ consumer_th = create(consumer, 1024, 20, "consumer", 3, count);

  resume(consumer_th);
  resume(producer_th);

  return 0;
}
```

```
void producer(int count)
{
  while (n <= count) {
    printf("producing %d\n", ++n);
  }
}
```

```
void consumer(int count)
{
  while (n <= count) {
    printf("consuming %d\n", n);
  }
}
```

(see also the diff file submitted to Canvas)
